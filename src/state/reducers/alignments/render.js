import _ from 'lodash';
import {numberComparator} from './index';

/**
 * Generates an index of tokens that will be rendered.
 * @param {object[]} alignments - an array of alignments
 * @param {object[]} suggestions - an array of suggestions
 * @return {{source: Array, target: Array}}
 */
export const indexTokens = (alignments, suggestions) => {
  const sourceTokenIndex = [];
  const targetTokenIndex = [];
  const alignmentIndex = [];
  const suggestionIndex = [];

  // utility to initialize the token index
  const hydrateIndex = (index, i) => {
    if (!index[i]) {
      index[i] = {
        alignment: null,
        // TRICKY: tokens may be suggested that have already been used resulting in multiple matches.
        suggestions: []
      };
    }
    return index;
  };

  // index to alignments
  for (let a = 0; a < alignments.length; a++) {
    // index source tokens
    const sourceTokens = alignments[a].sourceNgram;
    for (let t = 0; t < sourceTokens.length; t++) {
      const position = sourceTokens[t];
      hydrateIndex(sourceTokenIndex, position);
      sourceTokenIndex[position].alignment = a;

      // perform general indexing of alignments
      const sourceLength = alignments[a].sourceNgram.length;
      alignmentIndex.push({
        index: a,
        aligned: alignments[a].targetNgram.length > 0,
        sourceLength,
        targetLength: alignments[a].targetNgram.length,
        isEmpty: alignments[a].targetNgram.length === 0,
        sourceId: alignments[a].sourceNgram.join(),
        targetId: alignments[a].targetNgram.join(),
        targetNgram: alignments[a].targetNgram,
        lastSourceToken: alignments[a].sourceNgram[sourceLength - 1]
      });
    }
    // index target tokens
    const targetTokens = alignments[a].targetNgram;
    for (let t = 0; t < targetTokens.length; t++) {
      const position = targetTokens[t];
      hydrateIndex(targetTokenIndex, position);
      targetTokenIndex[position].alignment = a;
    }
  }

  // index to suggestions
  for (let s = 0; s < suggestions.length; s++) {
    // index source tokens
    const sourceTokens = suggestions[s].sourceNgram;
    for (let t = 0; t < sourceTokens.length; t++) {
      const position = sourceTokens[t];
      hydrateIndex(sourceTokenIndex, position);
      sourceTokenIndex[position].suggestions.push(s);

      // perform general indexing of suggestions
      const sourceLength = suggestions[s].sourceNgram.length;
      suggestionIndex.push({
        index: s,
        sourceLength,
        targetLength: suggestions[s].targetNgram.length,
        isEmpty: suggestions[s].targetNgram.length === 0,
        sourceId: suggestions[s].sourceNgram.join(),
        targetId: suggestions[s].targetNgram.join(),
        targetNgram: suggestions[s].targetNgram,
        lastSourceToken: suggestions[s].sourceNgram[sourceLength - 1]
      });
    }
    // index target tokens
    const targetTokens = suggestions[s].targetNgram;
    for (let t = 0; t < targetTokens.length; t++) {
      const position = targetTokens[t];
      hydrateIndex(targetTokenIndex, position);
      targetTokenIndex[position].suggestions.push(s);
    }
  }

  return {
    source: sourceTokenIndex,
    target: targetTokenIndex,
    // TODO: some day if we re-write the renderer this may be helpful
    // alignments: alignmentIndex,
    // suggestions: suggestionIndex
  };
};

/**
 * Generates an index of suggestions associated with each alignment.
 * This is the inverse of {@link indexSuggestionAlignments}
 * @param {object} tokenIndex - an index generated by {@link indexTokens}
 * @return {object} - the index
 */
export const indexAlignmentSuggestions = tokenIndex => {
  const alignmentIndex = {};

  for (let t = 0; t < tokenIndex.source.length; t++) {
    const tempIndex = tokenIndex.source[t]; // index of a single token
    const alignmentPos = tempIndex.alignment;
    if (!alignmentIndex[alignmentPos]) {
      alignmentIndex[alignmentPos] = [];
    }
    alignmentIndex[alignmentPos].push(...tempIndex.suggestions);
  }

  return alignmentIndex;
};

/**
 * Generates an index of alignments associated with each suggestion.
 * This is the inverse of {@link indexAlignmentSuggestions}
 * @param {object} alignmentSuggestionsIndex - the index generated by {@link indexAlignmentSuggestions}
 * @return {object} - the index
 */
export const indexSuggestionAlignments = alignmentSuggestionsIndex => {
  const suggestionIndex = {};

  const numAlignments = Object.keys(alignmentSuggestionsIndex).length;
  for (let a = 0; a < numAlignments; a++) {
    for (let s = 0; s < alignmentSuggestionsIndex[a].length; s++) {
      const suggestionPos = alignmentSuggestionsIndex[a][s];
      if (!suggestionIndex[suggestionPos]) {
        suggestionIndex[suggestionPos] = [];
      }
      suggestionIndex[suggestionPos].push(a);
    }
  }

  return suggestionIndex;
};

/**
 * Renders the verse alignments with the suggestions
 * @param {object[]} alignments - an array of alignments
 * @param {object[]} suggestions - an array of alignment suggestions
 * @param {number} numSourceTokens - the number of source tokens in the verse
 * @return the alignments rendered with suggestions.
 */
const render = (alignments, suggestions, numSourceTokens) => {
  // index things
  const tokenIndex = indexTokens(alignments, suggestions);
  const alignmentSuggestionsIndex = indexAlignmentSuggestions(tokenIndex);

  const alignmentSourceIndex = [];
  const suggestionSourceIndex = [];
  const targetIndex = {};
  for (let aIndex = 0; aIndex < alignments.length; aIndex++) {
    for (const pos of alignments[aIndex].targetNgram) {
      targetIndex[pos] = aIndex;
    }
    for (let i = 0; i < alignments[aIndex].sourceNgram.length; i++) {
      const sourceLength = alignments[aIndex].sourceNgram.length;
      // TRICKY: the source tokens will be in order spread over the alignments
      alignmentSourceIndex.push({
        index: aIndex,
        aligned: alignments[aIndex].targetNgram.length > 0,
        sourceLength,
        targetLength: alignments[aIndex].targetNgram.length,
        isEmpty: alignments[aIndex].targetNgram.length === 0,
        sourceId: alignments[aIndex].sourceNgram.join(),
        targetId: alignments[aIndex].targetNgram.join(),
        targetNgram: alignments[aIndex].targetNgram,
        lastSourceToken: alignments[aIndex].sourceNgram[sourceLength - 1]
      });
    }
  }
  for (let sIndex = 0; sIndex < suggestions.length; sIndex++) {
    for (let i = 0; i < suggestions[sIndex].sourceNgram.length; i++) {
      const sourceLength = suggestions[sIndex].sourceNgram.length;
      // TRICKY: the source tokens will be in order spread over the suggestions
      suggestionSourceIndex.push({
        index: sIndex,
        sourceLength,
        targetLength: suggestions[sIndex].targetNgram.length,
        isEmpty: suggestions[sIndex].targetNgram.length === 0,
        sourceId: suggestions[sIndex].sourceNgram.join(),
        targetId: suggestions[sIndex].targetNgram.join(),
        targetNgram: suggestions[sIndex].targetNgram,
        lastSourceToken: suggestions[sIndex].sourceNgram[sourceLength - 1]
      });
    }
  }

  // TRICKY: we don't support partial suggestion coverage at the moment
  if (suggestionSourceIndex.length > 0 && suggestionSourceIndex.length !==
    numSourceTokens) {
    console.error(
      'Index out of bounds. We currently do not support partial suggestions.');
    return [...convertToRendered(alignments)];
  }

  // TRICKY: short circuit invalid alignments
  if (alignmentSourceIndex.length !== numSourceTokens) {
    console.error(`Alignments are corrupt. Expected ${numSourceTokens} but received ${alignmentSourceIndex.length}`, alignments, suggestions);
    return [...convertToRendered(alignments)];
  }

  // build output
  const suggestedAlignments = [];
  let alignmentQueue = []; // track how many alignments span a suggestion
  let suggestionStateIsValid = true;
  for (let tIndex = 0; tIndex < numSourceTokens; tIndex++) {
    const alignmentPos = alignmentSourceIndex[tIndex].index;
    if (alignmentQueue.indexOf(alignmentSourceIndex[tIndex].index) === -1) {
      alignmentQueue.push(alignmentSourceIndex[tIndex].index);
    }

    const alignmentIsAligned = alignmentSourceIndex[tIndex].aligned;
    const finishedReadingAlignment = alignmentSourceIndex[tIndex].lastSourceToken ===
      tIndex;
    const suggestionSpansMultiple = alignmentQueue.length > 1;

    let targetUsedElsewhere = false;

    // determine suggestion validity
    let suggestionIsValid = false;
    let finishedReadingSuggestion = false;
    let sourceNgramsMatch = false;
    // TRICKY: we may not have suggestions for everything
    if (tIndex < suggestionSourceIndex.length) {
      // check if suggested target tokens are already used
      for (const targetPos of suggestionSourceIndex[tIndex].targetNgram) {
        if (targetPos in targetIndex) {
          const index = targetIndex[targetPos];
          targetUsedElsewhere = alignmentQueue.indexOf(index) === -1;
          if (targetUsedElsewhere) {
            break;
          }
        }
      }

      finishedReadingSuggestion = suggestionSourceIndex[tIndex].lastSourceToken ===
        tIndex;
      const suggestionTargetIsSuperset = isSubArray(
        suggestionSourceIndex[tIndex].targetNgram,
        alignmentSourceIndex[tIndex].targetNgram);

      sourceNgramsMatch = alignmentSourceIndex[tIndex].sourceId ===
        suggestionSourceIndex[tIndex].sourceId;
      const targetNgramsMatch = alignmentSourceIndex[tIndex].targetId ===
        suggestionSourceIndex[tIndex].targetId;
      const isPerfectMatch = sourceNgramsMatch && targetNgramsMatch;
      const alignmentIsMerged = alignmentSourceIndex[tIndex].sourceLength > 1;

      const suggestionIsEmpty = suggestionSourceIndex[tIndex].isEmpty;
      let siblingSuggestionsAreEmpty = suggestionIsEmpty;
      const siblings = alignmentSuggestionsIndex[alignmentPos];
      if (suggestionIsEmpty && siblings) {
        for (let i = 0; i < siblings.length; i++) {
          if(suggestions[siblings[i]].targetNgram.length > 0) {
            siblingSuggestionsAreEmpty = false;
          }
        }
      }

      if (siblingSuggestionsAreEmpty) {
        // empty suggestions are always in-valid
        suggestionIsValid = false;
      } else if (!alignmentIsAligned && !alignmentIsMerged) {
        // TRICKY: for now we do not allow splitting merged alignments
        // un-aligned alignments are valid
        suggestionIsValid = true;
      } else if (!isPerfectMatch && finishedReadingAlignment &&
        finishedReadingSuggestion && !suggestionSpansMultiple &&
        suggestionTargetIsSuperset && sourceNgramsMatch) {
        // identical source n-grams are valid
        suggestionIsValid = true;
      } else if (!isPerfectMatch && !finishedReadingAlignment &&
        !finishedReadingSuggestion && !suggestionSpansMultiple &&
        suggestionTargetIsSuperset) {
        // incomplete readings are valid until proven otherwise
        suggestionIsValid = true;
      }
    }

    // TRICKY: persist invalid state through the entire suggestion.
    if (!suggestionIsValid) {
      suggestionStateIsValid = suggestionIsValid;
    }

    // renders a finished alignment
    const renderAlignment = () => {
      // use the alignment
      const index = alignmentQueue.pop();
      const rawAlignment = _.cloneDeep(alignments[index]);
      rawAlignment.alignments = [index];
      return rawAlignment;
    };

    // renders a finished suggestion
    const renderSuggestion = () => {
      const index = suggestionSourceIndex[tIndex].index;
      // merge target n-grams
      const rawSuggestion = _.cloneDeep(suggestions[index]);
      rawSuggestion.suggestedTargetTokens = [...rawSuggestion.targetNgram];
      for (const aIndex of alignmentQueue) {
        const rawAlignment = alignments[aIndex];
        for (const t of rawAlignment.targetNgram) {
          if (rawSuggestion.targetNgram.indexOf(t) === -1) {
            rawSuggestion.targetNgram.push(t);
          } else {
            _.pull(rawSuggestion.suggestedTargetTokens, t);
          }
        }
        rawSuggestion.targetNgram = _.union(rawSuggestion.targetNgram,
          rawAlignment.targetNgram);
      }
      rawSuggestion.alignments = [...alignmentQueue];
      rawSuggestion.suggestion = index;
      rawSuggestion.targetNgram.sort(numberComparator);
      if (suggestionSourceIndex[tIndex].isEmpty && sourceNgramsMatch) {
        // TRICKY: render empty matches as an alignment
        return {
          alignments: rawSuggestion.alignments,
          sourceNgram: rawSuggestion.sourceNgram,
          targetNgram: rawSuggestion.targetNgram
        };
      } else {
        return rawSuggestion;
      }
    };

    // TRICKY: if the suggested target tokens are used elsewhere we render the alignment
    const shouldRenderSuggestion = suggestionStateIsValid &&
      finishedReadingSuggestion && !targetUsedElsewhere;
    const shouldRenderAlignment = (!suggestionStateIsValid ||
      targetUsedElsewhere) && finishedReadingAlignment;

    // append finished readings
    if (shouldRenderSuggestion) {
      suggestedAlignments.push(renderSuggestion());
    } else if (shouldRenderAlignment) {
      suggestedAlignments.push(renderAlignment());
    }

    // clean up
    if (!suggestionStateIsValid && finishedReadingAlignment ||
      suggestionStateIsValid && finishedReadingSuggestion) {
      alignmentQueue = [];
    }
    if (finishedReadingSuggestion) {
      suggestionStateIsValid = true;
    }
  }

  return suggestedAlignments;
};

export default render;

/**
 * Converts some alignments to rendered alignments.
 * @param alignments
 * @return {*}
 */
export const convertToRendered = (alignments) => {
  return alignments.map((a, index) => {
    const newA = _.cloneDeep(a);
    newA.alignments = [index];
    return newA;
  });
};

/**
 * Checks if an array if a subset of another
 * @param superset
 * @param subset
 * @return {boolean}
 */
const isSubArray = (superset, subset) => {
  for (const val of subset) {
    if (!_.includes(superset, val)) {
      return false;
    }
  }
  return true;
};
